/* 
 * Blockchain.com Exchange REST API
 *
 * ## Introduction Welcome to Blockchain.com's Exchange API and developer documentation. \\ These documents detail and give examples of various functionality offered by the API such as receiving real time market data, requesting balance information and performing trades. ## To Get Started Create or log into your existing Blockchain.com Exchange account \\ Select API from the drop down menu \\ Fill out form and click “Create New API Key Now” \\ Once generated you can view your keys under API Settings. \\ Please be aware that the API key can only be used once it was verified via email.  The API key must be set via the \\ `X-API-Token`\\ header.  The base URL to be used for all calls is \\ `https://api.blockchain.com/v3/exchange`  Autogenerated clients for this API can be found [here](https://github.com/blockchain/lib-exchange-client). 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace Org.OpenAPITools.com.blockchain.exchange.rest.model;

/// <summary>
///   SymbolStatus
/// </summary>
[DataContract]
public class SymbolStatus : IEquatable<SymbolStatus>, IValidatableObject
{
	/// <summary>
	///   Symbol status; open, close, suspend, halt, halt-freeze.
	/// </summary>
	/// <value>Symbol status; open, close, suspend, halt, halt-freeze.</value>
	[JsonConverter(typeof(StringEnumConverter))]
	public enum StatusEnum
	{
		/// <summary>
		///   Enum Open for value: open
		/// </summary>
		[EnumMember(Value = "open")]
		Open = 1,
		/// <summary>
		///   Enum Close for value: close
		/// </summary>
		[EnumMember(Value = "close")]
		Close = 2,
		/// <summary>
		///   Enum Suspend for value: suspend
		/// </summary>
		[EnumMember(Value = "suspend")]
		Suspend = 3,
		/// <summary>
		///   Enum Halt for value: halt
		/// </summary>
		[EnumMember(Value = "halt")]
		Halt = 4,
		/// <summary>
		///   Enum HaltFreeze for value: halt-freeze
		/// </summary>
		[EnumMember(Value = "halt-freeze")]
		HaltFreeze = 5
	}

	/// <summary>
	///   Initializes a new instance of the <see cref="SymbolStatus" /> class.
	/// </summary>
	/// <param name="baseCurrency">Blockchain symbol identifier.</param>
	/// <param name="baseCurrencyScale">The number of decimals the currency can be split in.</param>
	/// <param name="counterCurrency">Blockchain symbol identifier.</param>
	/// <param name="counterCurrencyScale">The number of decimals the currency can be split in.</param>
	/// <param name="minPriceIncrement">
	///   The price of the instrument must be a multiple of min_price_increment *
	///   (10^-min_price_increment_scale).
	/// </param>
	/// <param name="minPriceIncrementScale">minPriceIncrementScale.</param>
	/// <param name="minOrderSize">
	///   The minimum quantity for an order for this instrument must be
	///   min_order_size*(10^-min_order_size_scale).
	/// </param>
	/// <param name="minOrderSizeScale">minOrderSizeScale.</param>
	/// <param name="maxOrderSize">
	///   The maximum quantity for an order for this instrument is
	///   max_order_size*(10^-max_order_size_scale). If this equal to zero, there is no limit.
	/// </param>
	/// <param name="maxOrderSizeScale">maxOrderSizeScale.</param>
	/// <param name="lotSize">lotSize.</param>
	/// <param name="lotSizeScale">lotSizeScale.</param>
	/// <param name="status">Symbol status; open, close, suspend, halt, halt-freeze..</param>
	/// <param name="id">id.</param>
	/// <param name="auctionPrice">If the symbol is halted and will open on an auction, this will be the opening price..</param>
	/// <param name="auctionSize">Opening size.</param>
	/// <param name="auctionTime">Opening time in HHMM format.</param>
	/// <param name="imbalance">
	///   Auction imbalance. If &gt; 0 then there will be buy orders left over at the auction price. If
	///   &lt; 0 then there will be sell orders left over at the auction price..
	/// </param>
	public SymbolStatus(string baseCurrency = default, int baseCurrencyScale = default,
		string counterCurrency = default, int counterCurrencyScale = default,
		long minPriceIncrement = default, int minPriceIncrementScale = default,
		long minOrderSize = default, int minOrderSizeScale = default, long maxOrderSize = default,
		int maxOrderSizeScale = default, long lotSize = default, int lotSizeScale = default,
		StatusEnum? status = default, long id = default, double auctionPrice = default,
		double auctionSize = default, string auctionTime = default, double imbalance = default)
	{
		BaseCurrency = baseCurrency;
		BaseCurrencyScale = baseCurrencyScale;
		CounterCurrency = counterCurrency;
		CounterCurrencyScale = counterCurrencyScale;
		MinPriceIncrement = minPriceIncrement;
		MinPriceIncrementScale = minPriceIncrementScale;
		MinOrderSize = minOrderSize;
		MinOrderSizeScale = minOrderSizeScale;
		MaxOrderSize = maxOrderSize;
		MaxOrderSizeScale = maxOrderSizeScale;
		LotSize = lotSize;
		LotSizeScale = lotSizeScale;
		Status = status;
		Id = id;
		AuctionPrice = auctionPrice;
		AuctionSize = auctionSize;
		AuctionTime = auctionTime;
		Imbalance = imbalance;
	}

	/// <summary>
	///   Symbol status; open, close, suspend, halt, halt-freeze.
	/// </summary>
	/// <value>Symbol status; open, close, suspend, halt, halt-freeze.</value>
	[DataMember(Name = "status", EmitDefaultValue = false)]
	public StatusEnum? Status { get; set; }
	/// <summary>
	///   Blockchain symbol identifier
	/// </summary>
	/// <value>Blockchain symbol identifier</value>
	[DataMember(Name = "base_currency", EmitDefaultValue = false)]
	public string BaseCurrency { get; set; }
	/// <summary>
	///   The number of decimals the currency can be split in
	/// </summary>
	/// <value>The number of decimals the currency can be split in</value>
	[DataMember(Name = "base_currency_scale", EmitDefaultValue = false)]
	public int BaseCurrencyScale { get; set; }
	/// <summary>
	///   Blockchain symbol identifier
	/// </summary>
	/// <value>Blockchain symbol identifier</value>
	[DataMember(Name = "counter_currency", EmitDefaultValue = false)]
	public string CounterCurrency { get; set; }
	/// <summary>
	///   The number of decimals the currency can be split in
	/// </summary>
	/// <value>The number of decimals the currency can be split in</value>
	[DataMember(Name = "counter_currency_scale", EmitDefaultValue = false)]
	public int CounterCurrencyScale { get; set; }
	/// <summary>
	///   The price of the instrument must be a multiple of min_price_increment * (10^-min_price_increment_scale)
	/// </summary>
	/// <value>The price of the instrument must be a multiple of min_price_increment * (10^-min_price_increment_scale)</value>
	[DataMember(Name = "min_price_increment", EmitDefaultValue = false)]
	public long MinPriceIncrement { get; set; }
	/// <summary>
	///   Gets or Sets MinPriceIncrementScale
	/// </summary>
	[DataMember(Name = "min_price_increment_scale", EmitDefaultValue = false)]
	public int MinPriceIncrementScale { get; set; }
	/// <summary>
	///   The minimum quantity for an order for this instrument must be min_order_size*(10^-min_order_size_scale)
	/// </summary>
	/// <value>The minimum quantity for an order for this instrument must be min_order_size*(10^-min_order_size_scale)</value>
	[DataMember(Name = "min_order_size", EmitDefaultValue = false)]
	public long MinOrderSize { get; set; }
	/// <summary>
	///   Gets or Sets MinOrderSizeScale
	/// </summary>
	[DataMember(Name = "min_order_size_scale", EmitDefaultValue = false)]
	public int MinOrderSizeScale { get; set; }
	/// <summary>
	///   The maximum quantity for an order for this instrument is max_order_size*(10^-max_order_size_scale). If this equal to
	///   zero, there is no limit
	/// </summary>
	/// <value>
	///   The maximum quantity for an order for this instrument is max_order_size*(10^-max_order_size_scale). If this
	///   equal to zero, there is no limit
	/// </value>
	[DataMember(Name = "max_order_size", EmitDefaultValue = false)]
	public long MaxOrderSize { get; set; }
	/// <summary>
	///   Gets or Sets MaxOrderSizeScale
	/// </summary>
	[DataMember(Name = "max_order_size_scale", EmitDefaultValue = false)]
	public int MaxOrderSizeScale { get; set; }
	/// <summary>
	///   Gets or Sets LotSize
	/// </summary>
	[DataMember(Name = "lot_size", EmitDefaultValue = false)]
	public long LotSize { get; set; }
	/// <summary>
	///   Gets or Sets LotSizeScale
	/// </summary>
	[DataMember(Name = "lot_size_scale", EmitDefaultValue = false)]
	public int LotSizeScale { get; set; }
	/// <summary>
	///   Gets or Sets Id
	/// </summary>
	[DataMember(Name = "id", EmitDefaultValue = false)]
	public long Id { get; set; }
	/// <summary>
	///   If the symbol is halted and will open on an auction, this will be the opening price.
	/// </summary>
	/// <value>If the symbol is halted and will open on an auction, this will be the opening price.</value>
	[DataMember(Name = "auction_price", EmitDefaultValue = false)]
	public double AuctionPrice { get; set; }
	/// <summary>
	///   Opening size
	/// </summary>
	/// <value>Opening size</value>
	[DataMember(Name = "auction_size", EmitDefaultValue = false)]
	public double AuctionSize { get; set; }
	/// <summary>
	///   Opening time in HHMM format
	/// </summary>
	/// <value>Opening time in HHMM format</value>
	[DataMember(Name = "auction_time", EmitDefaultValue = false)]
	public string AuctionTime { get; set; }
	/// <summary>
	///   Auction imbalance. If &gt; 0 then there will be buy orders left over at the auction price. If &lt; 0 then there will
	///   be sell orders left over at the auction price.
	/// </summary>
	/// <value>
	///   Auction imbalance. If &gt; 0 then there will be buy orders left over at the auction price. If &lt; 0 then there
	///   will be sell orders left over at the auction price.
	/// </value>
	[DataMember(Name = "imbalance", EmitDefaultValue = false)]
	public double Imbalance { get; set; }

	/// <summary>
	///   Returns true if SymbolStatus instances are equal
	/// </summary>
	/// <param name="input">Instance of SymbolStatus to be compared</param>
	/// <returns>Boolean</returns>
	public bool Equals(SymbolStatus input)
	{
		if (input == null)
			return false;
		return
			(BaseCurrency == input.BaseCurrency ||
				(BaseCurrency != null && BaseCurrency.Equals(input.BaseCurrency))) &&
			(BaseCurrencyScale == input.BaseCurrencyScale || (BaseCurrencyScale != null &&
				BaseCurrencyScale.Equals(input.BaseCurrencyScale))) &&
			(CounterCurrency == input.CounterCurrency || (CounterCurrency != null &&
				CounterCurrency.Equals(input.CounterCurrency))) &&
			(CounterCurrencyScale == input.CounterCurrencyScale || (CounterCurrencyScale != null &&
				CounterCurrencyScale.Equals(input.CounterCurrencyScale))) &&
			(MinPriceIncrement == input.MinPriceIncrement || (MinPriceIncrement != null &&
				MinPriceIncrement.Equals(input.MinPriceIncrement))) &&
			(MinPriceIncrementScale == input.MinPriceIncrementScale ||
				(MinPriceIncrementScale != null &&
					MinPriceIncrementScale.Equals(input.MinPriceIncrementScale))) &&
			(MinOrderSize == input.MinOrderSize ||
				(MinOrderSize != null && MinOrderSize.Equals(input.MinOrderSize))) &&
			(MinOrderSizeScale == input.MinOrderSizeScale || (MinOrderSizeScale != null &&
				MinOrderSizeScale.Equals(input.MinOrderSizeScale))) &&
			(MaxOrderSize == input.MaxOrderSize ||
				(MaxOrderSize != null && MaxOrderSize.Equals(input.MaxOrderSize))) &&
			(MaxOrderSizeScale == input.MaxOrderSizeScale || (MaxOrderSizeScale != null &&
				MaxOrderSizeScale.Equals(input.MaxOrderSizeScale))) &&
			(LotSize == input.LotSize || (LotSize != null && LotSize.Equals(input.LotSize))) &&
			(LotSizeScale == input.LotSizeScale ||
				(LotSizeScale != null && LotSizeScale.Equals(input.LotSizeScale))) &&
			(Status == input.Status || (Status != null && Status.Equals(input.Status))) &&
			(Id == input.Id || (Id != null && Id.Equals(input.Id))) &&
			(AuctionPrice == input.AuctionPrice ||
				(AuctionPrice != null && AuctionPrice.Equals(input.AuctionPrice))) &&
			(AuctionSize == input.AuctionSize ||
				(AuctionSize != null && AuctionSize.Equals(input.AuctionSize))) &&
			(AuctionTime == input.AuctionTime ||
				(AuctionTime != null && AuctionTime.Equals(input.AuctionTime))) &&
			(Imbalance == input.Imbalance ||
				(Imbalance != null && Imbalance.Equals(input.Imbalance)));
	}

	/// <summary>
	///   To validate all properties of the instance
	/// </summary>
	/// <param name="validationContext">Validation context</param>
	/// <returns>Validation Result</returns>
	IEnumerable<ValidationResult> IValidatableObject.Validate(
		ValidationContext validationContext)
	{
		// BaseCurrency (string) pattern
		var regexBaseCurrency =
			new Regex(@"^[A-Z]{3,5}-[A-Z]{3,5}$", RegexOptions.CultureInvariant);
		if (false == regexBaseCurrency.Match(BaseCurrency).Success)
			yield return new ValidationResult(
				"Invalid value for BaseCurrency, must match a pattern of " + regexBaseCurrency,
				new[] { "BaseCurrency" });

		// CounterCurrency (string) pattern
		var regexCounterCurrency =
			new Regex(@"^[A-Z]{3,5}-[A-Z]{3,5}$", RegexOptions.CultureInvariant);
		if (false == regexCounterCurrency.Match(CounterCurrency).Success)
			yield return new ValidationResult(
				"Invalid value for CounterCurrency, must match a pattern of " + regexCounterCurrency,
				new[] { "CounterCurrency" });
	}

	/// <summary>
	///   Returns the string presentation of the object
	/// </summary>
	/// <returns>String presentation of the object</returns>
	public override string ToString()
	{
		var sb = new StringBuilder();
		sb.Append("class SymbolStatus {\n");
		sb.Append("  BaseCurrency: ").Append(BaseCurrency).Append("\n");
		sb.Append("  BaseCurrencyScale: ").Append(BaseCurrencyScale).Append("\n");
		sb.Append("  CounterCurrency: ").Append(CounterCurrency).Append("\n");
		sb.Append("  CounterCurrencyScale: ").Append(CounterCurrencyScale).Append("\n");
		sb.Append("  MinPriceIncrement: ").Append(MinPriceIncrement).Append("\n");
		sb.Append("  MinPriceIncrementScale: ").Append(MinPriceIncrementScale).Append("\n");
		sb.Append("  MinOrderSize: ").Append(MinOrderSize).Append("\n");
		sb.Append("  MinOrderSizeScale: ").Append(MinOrderSizeScale).Append("\n");
		sb.Append("  MaxOrderSize: ").Append(MaxOrderSize).Append("\n");
		sb.Append("  MaxOrderSizeScale: ").Append(MaxOrderSizeScale).Append("\n");
		sb.Append("  LotSize: ").Append(LotSize).Append("\n");
		sb.Append("  LotSizeScale: ").Append(LotSizeScale).Append("\n");
		sb.Append("  Status: ").Append(Status).Append("\n");
		sb.Append("  Id: ").Append(Id).Append("\n");
		sb.Append("  AuctionPrice: ").Append(AuctionPrice).Append("\n");
		sb.Append("  AuctionSize: ").Append(AuctionSize).Append("\n");
		sb.Append("  AuctionTime: ").Append(AuctionTime).Append("\n");
		sb.Append("  Imbalance: ").Append(Imbalance).Append("\n");
		sb.Append("}\n");
		return sb.ToString();
	}

	/// <summary>
	///   Returns the JSON string presentation of the object
	/// </summary>
	/// <returns>JSON string presentation of the object</returns>
	public virtual string ToJson() => JsonConvert.SerializeObject(this, Formatting.Indented);

	/// <summary>
	///   Returns true if objects are equal
	/// </summary>
	/// <param name="input">Object to be compared</param>
	/// <returns>Boolean</returns>
	public override bool Equals(object input) => Equals(input as SymbolStatus);

	/// <summary>
	///   Gets the hash code
	/// </summary>
	/// <returns>Hash code</returns>
	public override int GetHashCode()
	{
		unchecked // Overflow is fine, just wrap
		{
			var hashCode = 41;
			if (BaseCurrency != null)
				hashCode = hashCode * 59 + BaseCurrency.GetHashCode();
			if (BaseCurrencyScale != null)
				hashCode = hashCode * 59 + BaseCurrencyScale.GetHashCode();
			if (CounterCurrency != null)
				hashCode = hashCode * 59 + CounterCurrency.GetHashCode();
			if (CounterCurrencyScale != null)
				hashCode = hashCode * 59 + CounterCurrencyScale.GetHashCode();
			if (MinPriceIncrement != null)
				hashCode = hashCode * 59 + MinPriceIncrement.GetHashCode();
			if (MinPriceIncrementScale != null)
				hashCode = hashCode * 59 + MinPriceIncrementScale.GetHashCode();
			if (MinOrderSize != null)
				hashCode = hashCode * 59 + MinOrderSize.GetHashCode();
			if (MinOrderSizeScale != null)
				hashCode = hashCode * 59 + MinOrderSizeScale.GetHashCode();
			if (MaxOrderSize != null)
				hashCode = hashCode * 59 + MaxOrderSize.GetHashCode();
			if (MaxOrderSizeScale != null)
				hashCode = hashCode * 59 + MaxOrderSizeScale.GetHashCode();
			if (LotSize != null)
				hashCode = hashCode * 59 + LotSize.GetHashCode();
			if (LotSizeScale != null)
				hashCode = hashCode * 59 + LotSizeScale.GetHashCode();
			if (Status != null)
				hashCode = hashCode * 59 + Status.GetHashCode();
			if (Id != null)
				hashCode = hashCode * 59 + Id.GetHashCode();
			if (AuctionPrice != null)
				hashCode = hashCode * 59 + AuctionPrice.GetHashCode();
			if (AuctionSize != null)
				hashCode = hashCode * 59 + AuctionSize.GetHashCode();
			if (AuctionTime != null)
				hashCode = hashCode * 59 + AuctionTime.GetHashCode();
			if (Imbalance != null)
				hashCode = hashCode * 59 + Imbalance.GetHashCode();
			return hashCode;
		}
	}
}