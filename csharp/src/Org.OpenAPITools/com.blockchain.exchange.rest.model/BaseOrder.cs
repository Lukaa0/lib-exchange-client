/* 
 * Blockchain.com Exchange REST API
 *
 * ## Introduction Welcome to Blockchain.com's Exchange API and developer documentation. \\ These documents detail and give examples of various functionality offered by the API such as receiving real time market data, requesting balance information and performing trades. ## To Get Started Create or log into your existing Blockchain.com Exchange account \\ Select API from the drop down menu \\ Fill out form and click “Create New API Key Now” \\ Once generated you can view your keys under API Settings. \\ Please be aware that the API key can only be used once it was verified via email.  The API key must be set via the \\ `X-API-Token`\\ header.  The base URL to be used for all calls is \\ `https://api.blockchain.com/v3/exchange`  Autogenerated clients for this API can be found [here](https://github.com/blockchain/lib-exchange-client). 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;

namespace Org.OpenAPITools.com.blockchain.exchange.rest.model
{
	/// <summary>
	///   BaseOrder
	/// </summary>
	[DataContract]
	public class BaseOrder : IEquatable<BaseOrder>, IValidatableObject
	{
		/// <summary>
		///   Initializes a new instance of the <see cref="BaseOrder" /> class.
		/// </summary>
		[JsonConstructorAttribute]
		protected BaseOrder() { }

		/// <summary>
		///   Initializes a new instance of the <see cref="BaseOrder" /> class.
		/// </summary>
		/// <param name="clOrdId">
		///   Reference field provided by client. Cannot exceed 20 characters, only alphanumeric characters are
		///   allowed. (required).
		/// </param>
		/// <param name="ordType">ordType (required).</param>
		/// <param name="symbol">Blockchain symbol identifier (required).</param>
		/// <param name="side">side (required).</param>
		/// <param name="orderQty">The order size in the terms of the base currency (required).</param>
		/// <param name="timeInForce">timeInForce.</param>
		/// <param name="price">The limit price for the order.</param>
		/// <param name="expireDate">expiry date in the format YYYYMMDD.</param>
		/// <param name="minQty">The minimum quantity required for an IOC fill.</param>
		/// <param name="stopPx">The limit price for the order.</param>
		public BaseOrder(string clOrdId = default, OrdType ordType = default,
			string symbol = default, Side side = default, double orderQty = default,
			TimeInForce? timeInForce = default, double price = default, int expireDate = default,
			double minQty = default, double stopPx = default)
		{
			// to ensure "clOrdId" is required (not null)
			if (clOrdId == null)
				throw new InvalidDataException(
					"clOrdId is a required property for BaseOrder and cannot be null");
			ClOrdId = clOrdId;

			// to ensure "ordType" is required (not null)
			if (ordType == null)
				throw new InvalidDataException(
					"ordType is a required property for BaseOrder and cannot be null");
			OrdType = ordType;

			// to ensure "symbol" is required (not null)
			if (symbol == null)
				throw new InvalidDataException(
					"symbol is a required property for BaseOrder and cannot be null");
			Symbol = symbol;

			// to ensure "side" is required (not null)
			if (side == null)
				throw new InvalidDataException(
					"side is a required property for BaseOrder and cannot be null");
			Side = side;

			// to ensure "orderQty" is required (not null)
			if (orderQty == null)
				throw new InvalidDataException(
					"orderQty is a required property for BaseOrder and cannot be null");
			OrderQty = orderQty;
			TimeInForce = timeInForce;
			Price = price;
			ExpireDate = expireDate;
			MinQty = minQty;
			StopPx = stopPx;
		}

		/// <summary>
		///   Gets or Sets TimeInForce
		/// </summary>
		[DataMember(Name = "timeInForce", EmitDefaultValue = false)]
		public TimeInForce? TimeInForce { get; set; }
		/// <summary>
		///   Reference field provided by client. Cannot exceed 20 characters, only alphanumeric characters are allowed.
		/// </summary>
		/// <value>Reference field provided by client. Cannot exceed 20 characters, only alphanumeric characters are allowed.</value>
		[DataMember(Name = "clOrdId", EmitDefaultValue = true)]
		public string ClOrdId { get; set; }
		/// <summary>
		///   Gets or Sets OrdType
		/// </summary>
		[DataMember(Name = "ordType", EmitDefaultValue = true)]
		public OrdType OrdType { get; set; }
		/// <summary>
		///   Blockchain symbol identifier
		/// </summary>
		/// <value>Blockchain symbol identifier</value>
		[DataMember(Name = "symbol", EmitDefaultValue = true)]
		public string Symbol { get; set; }
		/// <summary>
		///   Gets or Sets Side
		/// </summary>
		[DataMember(Name = "side", EmitDefaultValue = true)]
		public Side Side { get; set; }
		/// <summary>
		///   The order size in the terms of the base currency
		/// </summary>
		/// <value>The order size in the terms of the base currency</value>
		[DataMember(Name = "orderQty", EmitDefaultValue = true)]
		public double OrderQty { get; set; }
		/// <summary>
		///   The limit price for the order
		/// </summary>
		/// <value>The limit price for the order</value>
		[DataMember(Name = "price", EmitDefaultValue = false)]
		public double Price { get; set; }
		/// <summary>
		///   expiry date in the format YYYYMMDD
		/// </summary>
		/// <value>expiry date in the format YYYYMMDD</value>
		[DataMember(Name = "expireDate", EmitDefaultValue = false)]
		public int ExpireDate { get; set; }
		/// <summary>
		///   The minimum quantity required for an IOC fill
		/// </summary>
		/// <value>The minimum quantity required for an IOC fill</value>
		[DataMember(Name = "minQty", EmitDefaultValue = false)]
		public double MinQty { get; set; }
		/// <summary>
		///   The limit price for the order
		/// </summary>
		/// <value>The limit price for the order</value>
		[DataMember(Name = "stopPx", EmitDefaultValue = false)]
		public double StopPx { get; set; }

		/// <summary>
		///   Returns true if BaseOrder instances are equal
		/// </summary>
		/// <param name="input">Instance of BaseOrder to be compared</param>
		/// <returns>Boolean</returns>
		public bool Equals(BaseOrder input)
		{
			if (input == null)
				return false;
			return
				(ClOrdId == input.ClOrdId || (ClOrdId != null && ClOrdId.Equals(input.ClOrdId))) &&
				(OrdType == input.OrdType || (OrdType != null && OrdType.Equals(input.OrdType))) &&
				(Symbol == input.Symbol || (Symbol != null && Symbol.Equals(input.Symbol))) &&
				(Side == input.Side || (Side != null && Side.Equals(input.Side))) &&
				(OrderQty == input.OrderQty ||
					(OrderQty != null && OrderQty.Equals(input.OrderQty))) &&
				(TimeInForce == input.TimeInForce ||
					(TimeInForce != null && TimeInForce.Equals(input.TimeInForce))) &&
				(Price == input.Price || (Price != null && Price.Equals(input.Price))) &&
				(ExpireDate == input.ExpireDate ||
					(ExpireDate != null && ExpireDate.Equals(input.ExpireDate))) &&
				(MinQty == input.MinQty || (MinQty != null && MinQty.Equals(input.MinQty))) &&
				(StopPx == input.StopPx || (StopPx != null && StopPx.Equals(input.StopPx)));
		}

		/// <summary>
		///   To validate all properties of the instance
		/// </summary>
		/// <param name="validationContext">Validation context</param>
		/// <returns>Validation Result</returns>
		IEnumerable<ValidationResult> IValidatableObject.Validate(
			ValidationContext validationContext)
		{
			// ClOrdId (string) maxLength
			if (ClOrdId != null && ClOrdId.Length > 20)
				yield return new ValidationResult(
					"Invalid value for ClOrdId, length must be less than 20.", new[] { "ClOrdId" });

			// ClOrdId (string) pattern
			var regexClOrdId = new Regex(@"^[a-zA-Z0-9]{1,20}$", RegexOptions.CultureInvariant);
			if (false == regexClOrdId.Match(ClOrdId).Success)
				yield return new ValidationResult(
					"Invalid value for ClOrdId, must match a pattern of " + regexClOrdId,
					new[] { "ClOrdId" });

			// Symbol (string) pattern
			var regexSymbol = new Regex(@"^[A-Z]{3,5}-[A-Z]{3,5}$", RegexOptions.CultureInvariant);
			if (false == regexSymbol.Match(Symbol).Success)
				yield return new ValidationResult(
					"Invalid value for Symbol, must match a pattern of " + regexSymbol,
					new[] { "Symbol" });

			// ExpireDate (int) maximum
			if (ExpireDate > 20501231)
				yield return new ValidationResult(
					"Invalid value for ExpireDate, must be a value less than or equal to 20501231.",
					new[] { "ExpireDate" });

			// ExpireDate (int) minimum
			if (ExpireDate < 20200101)
				yield return new ValidationResult(
					"Invalid value for ExpireDate, must be a value greater than or equal to 20200101.",
					new[] { "ExpireDate" });
		}

		/// <summary>
		///   Returns the string presentation of the object
		/// </summary>
		/// <returns>String presentation of the object</returns>
		public override string ToString()
		{
			var sb = new StringBuilder();
			sb.Append("class BaseOrder {\n");
			sb.Append("  ClOrdId: ").Append(ClOrdId).Append("\n");
			sb.Append("  OrdType: ").Append(OrdType).Append("\n");
			sb.Append("  Symbol: ").Append(Symbol).Append("\n");
			sb.Append("  Side: ").Append(Side).Append("\n");
			sb.Append("  OrderQty: ").Append(OrderQty).Append("\n");
			sb.Append("  TimeInForce: ").Append(TimeInForce).Append("\n");
			sb.Append("  Price: ").Append(Price).Append("\n");
			sb.Append("  ExpireDate: ").Append(ExpireDate).Append("\n");
			sb.Append("  MinQty: ").Append(MinQty).Append("\n");
			sb.Append("  StopPx: ").Append(StopPx).Append("\n");
			sb.Append("}\n");
			return sb.ToString();
		}

		/// <summary>
		///   Returns the JSON string presentation of the object
		/// </summary>
		/// <returns>JSON string presentation of the object</returns>
		public virtual string ToJson() => JsonConvert.SerializeObject(this, Formatting.Indented);

		/// <summary>
		///   Returns true if objects are equal
		/// </summary>
		/// <param name="input">Object to be compared</param>
		/// <returns>Boolean</returns>
		public override bool Equals(object input) => Equals(input as BaseOrder);

		/// <summary>
		///   Gets the hash code
		/// </summary>
		/// <returns>Hash code</returns>
		public override int GetHashCode()
		{
			unchecked // Overflow is fine, just wrap
			{
				var hashCode = 41;
				if (ClOrdId != null)
					hashCode = hashCode * 59 + ClOrdId.GetHashCode();
				if (OrdType != null)
					hashCode = hashCode * 59 + OrdType.GetHashCode();
				if (Symbol != null)
					hashCode = hashCode * 59 + Symbol.GetHashCode();
				if (Side != null)
					hashCode = hashCode * 59 + Side.GetHashCode();
				if (OrderQty != null)
					hashCode = hashCode * 59 + OrderQty.GetHashCode();
				if (TimeInForce != null)
					hashCode = hashCode * 59 + TimeInForce.GetHashCode();
				if (Price != null)
					hashCode = hashCode * 59 + Price.GetHashCode();
				if (ExpireDate != null)
					hashCode = hashCode * 59 + ExpireDate.GetHashCode();
				if (MinQty != null)
					hashCode = hashCode * 59 + MinQty.GetHashCode();
				if (StopPx != null)
					hashCode = hashCode * 59 + StopPx.GetHashCode();
				return hashCode;
			}
		}
	}
}