/* 
 * Blockchain.com Exchange REST API
 *
 * ## Introduction Welcome to Blockchain.com's Exchange API and developer documentation. \\ These documents detail and give examples of various functionality offered by the API such as receiving real time market data, requesting balance information and performing trades. ## To Get Started Create or log into your existing Blockchain.com Exchange account \\ Select API from the drop down menu \\ Fill out form and click “Create New API Key Now” \\ Once generated you can view your keys under API Settings. \\ Please be aware that the API key can only be used once it was verified via email.  The API key must be set via the \\ `X-API-Token`\\ header.  The base URL to be used for all calls is \\ `https://api.blockchain.com/v3/exchange`  Autogenerated clients for this API can be found [here](https://github.com/blockchain/lib-exchange-client). 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;

namespace Org.OpenAPITools.com.blockchain.exchange.rest.model;

/// <summary>
///   OrderSummary
/// </summary>
[DataContract]
public class OrderSummary : IEquatable<OrderSummary>, IValidatableObject
{
	/// <summary>
	///   Initializes a new instance of the <see cref="OrderSummary" /> class.
	/// </summary>
	[JsonConstructorAttribute]
	protected OrderSummary() { }

	/// <summary>
	///   Initializes a new instance of the <see cref="OrderSummary" /> class.
	/// </summary>
	/// <param name="exOrdId">The unique order id assigned by the exchange.</param>
	/// <param name="clOrdId">
	///   Reference field provided by client. Cannot exceed 20 characters, only alphanumeric characters are
	///   allowed. (required).
	/// </param>
	/// <param name="ordType">ordType (required).</param>
	/// <param name="ordStatus">ordStatus (required).</param>
	/// <param name="side">side (required).</param>
	/// <param name="price">The limit price for the order.</param>
	/// <param name="text">The reason for rejecting the order, if applicable.</param>
	/// <param name="symbol">Blockchain symbol identifier (required).</param>
	/// <param name="lastShares">The executed quantity for the order&#39;s last fill.</param>
	/// <param name="lastPx">The executed price for the last fill.</param>
	/// <param name="leavesQty">
	///   For Open and Partially Filled orders this is the remaining quantity open for execution. For
	///   Canceled and Expired orders this is the quantity than was still open before cancellation/expiration. For Rejected
	///   order this is equal to orderQty. For other states this is always zero..
	/// </param>
	/// <param name="cumQty">The quantity of the order which has been filled.</param>
	/// <param name="avgPx">Calculated the Volume Weighted Average Price of all fills for this order.</param>
	/// <param name="timestamp">Time in ms since 01/01/1970 (epoch).</param>
	public OrderSummary(long exOrdId = default, string clOrdId = default,
		OrdType ordType = default, OrderStatus ordStatus = default, Side side = default,
		double price = default, string text = default, string symbol = default,
		double lastShares = default, double lastPx = default, double leavesQty = default,
		double cumQty = default, double avgPx = default, long timestamp = default)
	{
		// to ensure "clOrdId" is required (not null)
		if (clOrdId == null)
			throw new InvalidDataException(
				"clOrdId is a required property for OrderSummary and cannot be null");
		ClOrdId = clOrdId;

		// to ensure "ordType" is required (not null)
		if (ordType == null)
			throw new InvalidDataException(
				"ordType is a required property for OrderSummary and cannot be null");
		OrdType = ordType;

		// to ensure "ordStatus" is required (not null)
		if (ordStatus == null)
			throw new InvalidDataException(
				"ordStatus is a required property for OrderSummary and cannot be null");
		OrdStatus = ordStatus;

		// to ensure "side" is required (not null)
		if (side == null)
			throw new InvalidDataException(
				"side is a required property for OrderSummary and cannot be null");
		Side = side;

		// to ensure "symbol" is required (not null)
		if (symbol == null)
			throw new InvalidDataException(
				"symbol is a required property for OrderSummary and cannot be null");
		Symbol = symbol;
		ExOrdId = exOrdId;
		Price = price;
		Text = text;
		LastShares = lastShares;
		LastPx = lastPx;
		LeavesQty = leavesQty;
		CumQty = cumQty;
		AvgPx = avgPx;
		Timestamp = timestamp;
	}

	/// <summary>
	///   Gets or Sets OrdStatus
	/// </summary>
	[DataMember(Name = "ordStatus", EmitDefaultValue = true)]
	public OrderStatus OrdStatus { get; set; }
	/// <summary>
	///   The unique order id assigned by the exchange
	/// </summary>
	/// <value>The unique order id assigned by the exchange</value>
	[DataMember(Name = "exOrdId", EmitDefaultValue = false)]
	public long ExOrdId { get; set; }
	/// <summary>
	///   Reference field provided by client. Cannot exceed 20 characters, only alphanumeric characters are allowed.
	/// </summary>
	/// <value>Reference field provided by client. Cannot exceed 20 characters, only alphanumeric characters are allowed.</value>
	[DataMember(Name = "clOrdId", EmitDefaultValue = true)]
	public string ClOrdId { get; set; }
	/// <summary>
	///   Gets or Sets OrdType
	/// </summary>
	[DataMember(Name = "ordType", EmitDefaultValue = true)]
	public OrdType OrdType { get; set; }
	/// <summary>
	///   Gets or Sets Side
	/// </summary>
	[DataMember(Name = "side", EmitDefaultValue = true)]
	public Side Side { get; set; }
	/// <summary>
	///   The limit price for the order
	/// </summary>
	/// <value>The limit price for the order</value>
	[DataMember(Name = "price", EmitDefaultValue = false)]
	public double Price { get; set; }
	/// <summary>
	///   The reason for rejecting the order, if applicable
	/// </summary>
	/// <value>The reason for rejecting the order, if applicable</value>
	[DataMember(Name = "text", EmitDefaultValue = false)]
	public string Text { get; set; }
	/// <summary>
	///   Blockchain symbol identifier
	/// </summary>
	/// <value>Blockchain symbol identifier</value>
	[DataMember(Name = "symbol", EmitDefaultValue = true)]
	public string Symbol { get; set; }
	/// <summary>
	///   The executed quantity for the order&#39;s last fill
	/// </summary>
	/// <value>The executed quantity for the order&#39;s last fill</value>
	[DataMember(Name = "lastShares", EmitDefaultValue = false)]
	public double LastShares { get; set; }
	/// <summary>
	///   The executed price for the last fill
	/// </summary>
	/// <value>The executed price for the last fill</value>
	[DataMember(Name = "lastPx", EmitDefaultValue = false)]
	public double LastPx { get; set; }
	/// <summary>
	///   For Open and Partially Filled orders this is the remaining quantity open for execution. For Canceled and Expired
	///   orders this is the quantity than was still open before cancellation/expiration. For Rejected order this is equal to
	///   orderQty. For other states this is always zero.
	/// </summary>
	/// <value>
	///   For Open and Partially Filled orders this is the remaining quantity open for execution. For Canceled and Expired
	///   orders this is the quantity than was still open before cancellation/expiration. For Rejected order this is equal to
	///   orderQty. For other states this is always zero.
	/// </value>
	[DataMember(Name = "leavesQty", EmitDefaultValue = false)]
	public double LeavesQty { get; set; }
	/// <summary>
	///   The quantity of the order which has been filled
	/// </summary>
	/// <value>The quantity of the order which has been filled</value>
	[DataMember(Name = "cumQty", EmitDefaultValue = false)]
	public double CumQty { get; set; }
	/// <summary>
	///   Calculated the Volume Weighted Average Price of all fills for this order
	/// </summary>
	/// <value>Calculated the Volume Weighted Average Price of all fills for this order</value>
	[DataMember(Name = "avgPx", EmitDefaultValue = false)]
	public double AvgPx { get; set; }
	/// <summary>
	///   Time in ms since 01/01/1970 (epoch)
	/// </summary>
	/// <value>Time in ms since 01/01/1970 (epoch)</value>
	[DataMember(Name = "timestamp", EmitDefaultValue = false)]
	public long Timestamp { get; set; }

	/// <summary>
	///   Returns true if OrderSummary instances are equal
	/// </summary>
	/// <param name="input">Instance of OrderSummary to be compared</param>
	/// <returns>Boolean</returns>
	public bool Equals(OrderSummary input)
	{
		if (input == null)
			return false;
		return (ExOrdId == input.ExOrdId || (ExOrdId != null && ExOrdId.Equals(input.ExOrdId))) &&
			(ClOrdId == input.ClOrdId || (ClOrdId != null && ClOrdId.Equals(input.ClOrdId))) &&
			(OrdType == input.OrdType || (OrdType != null && OrdType.Equals(input.OrdType))) &&
			(OrdStatus == input.OrdStatus ||
				(OrdStatus != null && OrdStatus.Equals(input.OrdStatus))) &&
			(Side == input.Side || (Side != null && Side.Equals(input.Side))) &&
			(Price == input.Price || (Price != null && Price.Equals(input.Price))) &&
			(Text == input.Text || (Text != null && Text.Equals(input.Text))) &&
			(Symbol == input.Symbol || (Symbol != null && Symbol.Equals(input.Symbol))) &&
			(LastShares == input.LastShares ||
				(LastShares != null && LastShares.Equals(input.LastShares))) &&
			(LastPx == input.LastPx || (LastPx != null && LastPx.Equals(input.LastPx))) &&
			(LeavesQty == input.LeavesQty ||
				(LeavesQty != null && LeavesQty.Equals(input.LeavesQty))) &&
			(CumQty == input.CumQty || (CumQty != null && CumQty.Equals(input.CumQty))) &&
			(AvgPx == input.AvgPx || (AvgPx != null && AvgPx.Equals(input.AvgPx))) &&
			(Timestamp == input.Timestamp ||
				(Timestamp != null && Timestamp.Equals(input.Timestamp)));
	}

	/// <summary>
	///   To validate all properties of the instance
	/// </summary>
	/// <param name="validationContext">Validation context</param>
	/// <returns>Validation Result</returns>
	IEnumerable<ValidationResult> IValidatableObject.Validate(
		ValidationContext validationContext)
	{
		// ClOrdId (string) maxLength
		if (ClOrdId != null && ClOrdId.Length > 20)
			yield return new ValidationResult(
				"Invalid value for ClOrdId, length must be less than 20.", new[] { "ClOrdId" });

		// ClOrdId (string) pattern
		var regexClOrdId = new Regex(@"^[a-zA-Z0-9]{1,20}$", RegexOptions.CultureInvariant);
		if (false == regexClOrdId.Match(ClOrdId).Success)
			yield return new ValidationResult(
				"Invalid value for ClOrdId, must match a pattern of " + regexClOrdId,
				new[] { "ClOrdId" });

		// Symbol (string) pattern
		var regexSymbol = new Regex(@"^[A-Z]{3,5}-[A-Z]{3,5}$", RegexOptions.CultureInvariant);
		if (false == regexSymbol.Match(Symbol).Success)
			yield return new ValidationResult(
				"Invalid value for Symbol, must match a pattern of " + regexSymbol,
				new[] { "Symbol" });
	}

	/// <summary>
	///   Returns the string presentation of the object
	/// </summary>
	/// <returns>String presentation of the object</returns>
	public override string ToString()
	{
		var sb = new StringBuilder();
		sb.Append("class OrderSummary {\n");
		sb.Append("  ExOrdId: ").Append(ExOrdId).Append("\n");
		sb.Append("  ClOrdId: ").Append(ClOrdId).Append("\n");
		sb.Append("  OrdType: ").Append(OrdType).Append("\n");
		sb.Append("  OrdStatus: ").Append(OrdStatus).Append("\n");
		sb.Append("  Side: ").Append(Side).Append("\n");
		sb.Append("  Price: ").Append(Price).Append("\n");
		sb.Append("  Text: ").Append(Text).Append("\n");
		sb.Append("  Symbol: ").Append(Symbol).Append("\n");
		sb.Append("  LastShares: ").Append(LastShares).Append("\n");
		sb.Append("  LastPx: ").Append(LastPx).Append("\n");
		sb.Append("  LeavesQty: ").Append(LeavesQty).Append("\n");
		sb.Append("  CumQty: ").Append(CumQty).Append("\n");
		sb.Append("  AvgPx: ").Append(AvgPx).Append("\n");
		sb.Append("  Timestamp: ").Append(Timestamp).Append("\n");
		sb.Append("}\n");
		return sb.ToString();
	}

	/// <summary>
	///   Returns the JSON string presentation of the object
	/// </summary>
	/// <returns>JSON string presentation of the object</returns>
	public virtual string ToJson() => JsonConvert.SerializeObject(this, Formatting.Indented);

	/// <summary>
	///   Returns true if objects are equal
	/// </summary>
	/// <param name="input">Object to be compared</param>
	/// <returns>Boolean</returns>
	public override bool Equals(object input) => Equals(input as OrderSummary);

	/// <summary>
	///   Gets the hash code
	/// </summary>
	/// <returns>Hash code</returns>
	public override int GetHashCode()
	{
		unchecked // Overflow is fine, just wrap
		{
			var hashCode = 41;
			if (ExOrdId != null)
				hashCode = hashCode * 59 + ExOrdId.GetHashCode();
			if (ClOrdId != null)
				hashCode = hashCode * 59 + ClOrdId.GetHashCode();
			if (OrdType != null)
				hashCode = hashCode * 59 + OrdType.GetHashCode();
			if (OrdStatus != null)
				hashCode = hashCode * 59 + OrdStatus.GetHashCode();
			if (Side != null)
				hashCode = hashCode * 59 + Side.GetHashCode();
			if (Price != null)
				hashCode = hashCode * 59 + Price.GetHashCode();
			if (Text != null)
				hashCode = hashCode * 59 + Text.GetHashCode();
			if (Symbol != null)
				hashCode = hashCode * 59 + Symbol.GetHashCode();
			if (LastShares != null)
				hashCode = hashCode * 59 + LastShares.GetHashCode();
			if (LastPx != null)
				hashCode = hashCode * 59 + LastPx.GetHashCode();
			if (LeavesQty != null)
				hashCode = hashCode * 59 + LeavesQty.GetHashCode();
			if (CumQty != null)
				hashCode = hashCode * 59 + CumQty.GetHashCode();
			if (AvgPx != null)
				hashCode = hashCode * 59 + AvgPx.GetHashCode();
			if (Timestamp != null)
				hashCode = hashCode * 59 + Timestamp.GetHashCode();
			return hashCode;
		}
	}
}